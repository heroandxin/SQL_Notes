# SQL Notes

Personal Notes and references on SQL. Taken from various places on the internet. (keep updating)

## Table of Contents
* [Window Functions](#window-functions)


## Window Functions

* `group by` will compress the result, `partition by` will not

Here is an example [LeetCode_1303_Easy](https://leetcode.com/problems/find-the-team-size/).


```text
Table: Employee
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| employee_id   | int     |
| team_id       | int     |
+---------------+---------+
employee_id is the primary key for this table.
Each row of this table contains the ID of each employee and their respective team.

Write an SQL query to find the team size of each of the employees.

Return result table in any order.


Input: 
Employee Table:
+-------------+------------+
| employee_id | team_id    |
+-------------+------------+
|     1       |     8      |
|     2       |     8      |
|     3       |     8      |
|     4       |     7      |
|     5       |     9      |
|     6       |     9      |
+-------------+------------+
Output: 
+-------------+------------+
| employee_id | team_size  |
+-------------+------------+
|     1       |     3      |
|     2       |     3      |
|     3       |     3      |
|     4       |     1      |
|     5       |     2      |
|     6       |     2      |
+-------------+------------+
Explanation: 
Employees with Id 1,2,3 are part of a team with team_id = 8.
Employee with Id 4 is part of a team with team_id = 7.
Employees with Id 5,6 are part of a team with team_id = 9.
```

```SQL
SELECT 
    employee_id,
    COUNT(employee_id) OVER (partition by team_id) AS team_size

FROM Employee
```

* All window functions are to expand a column and then filter on the new table
 
Here is an example [LeetCode_1126_Medium](https://leetcode.com/problems/active-businesses/).

```text
Table: Events

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| business_id   | int     |
| event_type    | varchar |
| occurences    | int     | 
+---------------+---------+
(business_id, event_type) is the primary key of this table.
Each row in the table logs the info that an event of some type occurred at some business for a number of times.
 

The average activity for a particular event_type is the average occurences across all companies that have this event.

An active business is a business that has more than one event_type such that their occurences is strictly greater than the average activity for that event.

Write an SQL query to find all active businesses.

Return the result table in any order.

The query result format is in the following example.

 

Example 1:

Input: 
Events table:
+-------------+------------+------------+
| business_id | event_type | occurences |
+-------------+------------+------------+
| 1           | reviews    | 7          |
| 3           | reviews    | 3          |
| 1           | ads        | 11         |
| 2           | ads        | 7          |
| 3           | ads        | 6          |
| 1           | page views | 3          |
| 2           | page views | 12         |
+-------------+------------+------------+
Output: 
+-------------+
| business_id |
+-------------+
| 1           |
+-------------+
Explanation:  
The average activity for each event can be calculated as follows:
- 'reviews': (7+3)/2 = 5
- 'ads': (11+7+6)/3 = 8
- 'page views': (3+12)/2 = 7.5
The business with id=1 has 7 'reviews' events (more than 5) and 11 'ads' events (more than 8), so it is an active business.
```

```SQL
SELECT 
    business_id
FROM
(SELECT 
    a.*,
    AVG(occurences) OVER(partition by event_type) AS avgo
FROM 
    Events a) tmp
WHERE occurences > avgo
GROUP BY business_id
HAVING COUNT(event_type) > 1
```

## Self Join

* Sometimes using `where in` **subquery** can get the same results

Here is an example [LeetCode_641_Medium](https://leetcode.com/problems/second-degree-follower/).

```text
Table: Follow

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| followee    | varchar |
| follower    | varchar |
+-------------+---------+
(followee, follower) is the primary key column for this table.
Each row of this table indicates that the user follower follows the user followee on a social network.
There will not be a user following themself.

A second-degree follower is a user who:

follows at least one user, and
is followed by at least one user.
Write an SQL query to report the second-degree users and the number of their followers.

Return the result table ordered by follower in alphabetical order.

Input: 
Follow table:
+----------+----------+
| followee | follower |
+----------+----------+
| Alice    | Bob      |
| Bob      | Cena     |
| Bob      | Donald   |
| Donald   | Edward   |
+----------+----------+
Output: 
+----------+-----+
| follower | num |
+----------+-----+
| Bob      | 2   |
| Donald   | 1   |
+----------+-----+
Explanation: 
User Bob has 2 followers. Bob is a second-degree follower because he follows Alice, so we include him in the result table.
User Donald has 1 follower. Donald is a second-degree follower because he follows Bob, so we include him in the result table.
User Alice has 1 follower. Alice is not a second-degree follower because she does not follow anyone, so we don not include her in the result table.
```
Solution 1 using `where in` **subquery**:

```SQL
SELECT 
    followee AS follower,
    COUNT(DISTINCT follower) AS num
FROM 
    Follow
WHERE 
    followee in
    (SELECT
        DISTINCT follower
    FROM
        Follow)
GROUP BY 1
```

Solution 2 using `Self Join`:

```SQL
SELECT
    a.followee as follower,
    COUNT(DISTINCT a.follower) AS num
FROM
    Follow a, Follow b
WHERE
    a.followee = b.follower
GROUP BY 1
```
